<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker Tutorial</title>
    <url>/articles/Docker-Tutorial/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_39135287/category_9492725.html"> Docker入门到实践</a></p>
<p><a href="https://www.docker.org.cn/book/install/rhel-docker-dependance-28.html">docker中文社区</a></p>
<p><a href="https://vuepress.mirror.docker-practice.com/introduction/what/">什么是 Docker | docker-practice.com</a></p>
<p>docker-ce引擎版本：20.10.16</p>
<p>id可以只打前几位，能区分就行。</p>
<p>不推荐装MySql</p>
<p><strong>查找容器两法</strong></p>
<ul>
<li>容器id</li>
<li>容器名:tag    — tag通过images可以查，不能省tag！！ （latest的tag可以省</li>
</ul>
<h1>名词概念</h1>
<p><strong>容器  &gt;  镜像  &gt;  程序</strong></p>
<ul>
<li>**dockfile：**自动化的脚本，自动创建镜像Image。</li>
<li><strong>Image镜像：</strong>  相当于虚拟机的快照，通过一个镜像可以创建多个容器。    ----   像应用商店的APP、Cent7.iso
<ul>
<li>tomcat镜像 ===&gt; run  ==&gt;tomcat容器（提供服务器），最终在容器中跑项目。</li>
<li>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</li>
<li>所有的应用，直接打包 <code>Docker</code> 镜像，就可以直接跑起来！       得到镜像的方法如下
<ul>
<li>从远程仓库下载</li>
<li>朋友拷贝给你</li>
<li>自己制作一个镜像 <code>DockerFile</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>Container容器：</strong> 相当于虚拟机，有着一整套的环境，和其他环境互不干扰。  被一个进程管理，进程停，容器停。  —虚拟机</li>
<li><strong>仓库Repository：</strong>  存放镜像的地方！！ 类似Maven仓库，分为公有和私有。
<ul>
<li>例子：默认Docker Hub国外慢，阿里云镜像加速快</li>
</ul>
</li>
</ul>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212051415882.png" alt="image-20220526234442510"/>
<p>相较于以往的jar包部署，Docker更方便部署。</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212051415884.png" alt="image-20220526230512571" style="zoom:80%;" />
<h1>虚拟、容器技术</h1>
<h2 id="1、传统虚拟技术"><a class="header-anchor" href="#1、传统虚拟技术">¶</a>1、传统虚拟技术</h2>
<p><strong>加载Guest OS</strong></p>
<p>每次新建都需重新加载内核，进行引导</p>
<p><strong>须要虚拟的有：</strong></p>
<blockquote>
<p>硬件、操作系统、内核。   — 典例：虚拟机</p>
</blockquote>
<p><img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212051415885.png" alt="image-20220526232235444"></p>
<h2 id="2、Docker虚拟技术"><a class="header-anchor" href="#2、Docker虚拟技术">¶</a>2、Docker虚拟技术</h2>
<p><strong>有着更少的抽象层</strong></p>
<p><strong>方便的升级和扩缩容</strong></p>
<p>项目打包为一个镜像，须要升级时升级镜像即可。</p>
<p><strong>操作系统层面</strong>的虚拟化技术，利用宿主机的内核</p>
<blockquote>
<p>无硬件、无OS，新建容器无需重新加载内核，更加轻便。</p>
</blockquote>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212051415886.png" alt="image-20220526233237679" style="zoom:50%;" />
<h1>安装Docker</h1>
<p><a href="https://blog.csdn.net/u014069688/article/details/100532774?">Centos7下安装Docker</a></p>
<p><a href="https://blog.csdn.net/cbh1987/article/details/120481157">Centos7安装docker</a></p>
<p>使用虚拟机192.168.86.128安装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 查看内核版本   --- 要高于<span class="number">3.10</span></span><br><span class="line">[root<span class="meta">@lzwEdu01</span> ~]# uname -r</span><br><span class="line"><span class="number">3.10</span><span class="number">.0</span>-<span class="number">957.</span>el7.x86_64</span><br><span class="line"></span><br><span class="line"># 查看OS    </span><br><span class="line">[root<span class="meta">@lzwEdu01</span> ~]# cat /etc/os-release</span><br><span class="line">NAME=<span class="string">&quot;CentOS Linux&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;7 (Core)&quot;</span></span><br><span class="line">ID=<span class="string">&quot;centos&quot;</span></span><br><span class="line">ID_LIKE=<span class="string">&quot;rhel fedora&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;7&quot;</span></span><br><span class="line">PRETTY_NAME=<span class="string">&quot;CentOS Linux 7 (Core)&quot;</span></span><br><span class="line">ANSI_COLOR=<span class="string">&quot;0;31&quot;</span></span><br><span class="line">CPE_NAME=<span class="string">&quot;cpe:/o:centos:centos:7&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;https://www.centos.org/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.centos.org/&quot;</span></span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=<span class="string">&quot;CentOS-7&quot;</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=<span class="string">&quot;7&quot;</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT=<span class="string">&quot;centos&quot;</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=<span class="string">&quot;7&quot;</span>    </span><br></pre></td></tr></table></figure>
<p>帮助文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># <span class="number">1</span>、卸载之前的docker</span><br><span class="line">    sudo yum remove docker \</span><br><span class="line">                docker-client \</span><br><span class="line">                docker-client-latest \</span><br><span class="line">                docker-common \</span><br><span class="line">                docker-latest \</span><br><span class="line">                docker-latest-logrotate \</span><br><span class="line">                docker-logrotate \</span><br><span class="line">                docker-selinux \</span><br><span class="line">                docker-engine-selinux \</span><br><span class="line">                docker-engine</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</span><br><span class="line">    sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">    </span><br><span class="line"># <span class="number">3</span>、设置yum的docker的源（默认国外，改为阿里云</span><br><span class="line">国外慢：    https:<span class="comment">//download.docker.com/linux/centos/docker-ce.repo </span></span><br><span class="line">阿里云快：    yum-config-manager --add-repo http:<span class="comment">//mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br><span class="line"></span><br><span class="line"># 狂神额外更新索引</span><br><span class="line">    yum makecache fast</span><br><span class="line">    </span><br><span class="line"># <span class="number">4</span>、安装docker引擎，是引擎哦  （docker-ce社区版，ee商业版</span><br><span class="line">    查看可安装的版本  yum list docker-ce --showduplicates | sort -r</span><br><span class="line">    安装最新版   yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line">    </span><br><span class="line"># <span class="number">5</span>、看版本 </span><br><span class="line">    docker version    </span><br><span class="line">    </span><br><span class="line"># <span class="number">6</span>、启动docker</span><br><span class="line">    systemctl start docker</span><br><span class="line">    </span><br><span class="line"># <span class="number">7</span>、运行hello world （先拉取镜像hello-world</span><br><span class="line">    docker run hello-world</span><br></pre></td></tr></table></figure>
<p>默认工作目录：<code>/var/lib/docker</code></p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212051415888.png" alt="image-20220527003822222" style="zoom:80%;" />
<hr>
<h1>阿里云镜像加速</h1>
<p><strong>可以省略</strong></p>
<p>支付宝阿里云账号</p>
<p>搜索：云服务 —&gt; 容器镜像服务  —&gt;  镜像工具  —&gt;  镜像加速器  —&gt; CentOs</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://4gf7t49m.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">    </span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker      --- 重启</span><br></pre></td></tr></table></figure>
<hr>
<h1>HelloWorld回顾</h1>
<p><code>docker run hello-world</code> 命令的步骤有：</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212051415889.png" alt="image-20220527122342623" style="zoom:80%;" />
<hr>
<h1>底层原理</h1>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212051415890.png" alt="image-20220527123137397" style="zoom:80%;" />
]]></content>
      <categories>
        <category>Tool</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Docker</tag>
        <tag>Tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub托管Hexo博客搭建全过程</title>
    <url>/articles/GitHub%E6%89%98%E7%AE%A1Hexo%E5%8D%9A%E5%AE%A2%20Butterfly%E4%B8%BB%E9%A2%98%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>本教程长期更新。</p>
<p><strong>前言</strong> : 折腾了好久我的Hexo Butterfly主题博客，中间经历无数令人抓狂的bug，深感个人博客搭建不易，在此写下保姆级全流程教程，希望充当集锦和回忆录，帮助博客新手避坑。遇到了什么困难都可以评论，知无不言。</p>
<p><strong>环境</strong> : Windows 10 64位，Linux和MacOS会有差别，但流程差不多</p>
<p><strong>优秀博客案例欣赏：</strong>  <a href="https://lzw-github.github.io/">Hexo - WinstonLi的个人博客 (lzw-github.github.io)</a></p>
<div class="aplayer" data-id="000PeZCQ1i4XVs" data-server="tencent" data-type="artist" data-mutex="true" data-preload="auto" data-theme="#3F51B5"></div>
<h1>Git安装配置，绑定GitHub账号</h1>
<p><strong>下载</strong>：搜索Git官网，下载64位setup，如Git-2.32.0-64-bit.exe</p>
<p><strong>安装</strong> ：无脑下一步，Git Bash是Git的命令行，如果选了只GitBash，那在cmd中使用git会报’git’ 不是内部或外部命令，解决办法是把Git安装文件夹下bin目录、git-core加入到环境变量中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Git安装目录\bin</span><br><span class="line"></span><br><span class="line">Git安装目录\mingw64\libexec\git-core</span><br></pre></td></tr></table></figure>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212061915388.png" alt="image-20221206191429644" style="zoom:80%;" />
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212071100043.png" alt="image-20221206191639793" style="zoom:80%;" />
<p><strong>设置用户全局签名</strong> ： 会记录在 <code>C:\users\用户\.gitconfig</code>里面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;账户名&quot;       账户名随便写几个字母</span><br><span class="line">git config --global user.email &quot;邮箱地址&quot;     邮箱随便写，瞎写都行。</span><br><span class="line">git config --global --list				查看写对了吗    </span><br></pre></td></tr></table></figure>
<p><strong>配置Git绑定GitHub</strong>：</p>
<p>鼠标右键选GitBash，输入 <code>ssh-keygen -t rsa</code> ，显示overwrite时输入y，其他时候按三次回车。</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212062145500.png" alt="image-20221206214526322" style="zoom:80%;" />
<p>之后在<code>C:\Users\用户\.ssh</code>下，有一个rsa后缀的私钥文件，要严密保管。 有一个pub后缀的公钥文件，复制公钥的内容，到GitHub网站你头像下面settings -&gt; SSH and GPG keys -&gt; new SSH key，Title随便写，Key部分填你的公钥内容。</p>
<p>在 <code>GitBash</code> 中输入 <code>ssh -T git@github.com</code> ，看到有successfully就说明绑定好了。</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212062146968.png" alt="image-20221206214628634" style="zoom:80%;" />
<p>参考链接：跳转前可以给我点一个赞吗，拜托拜托`(<em>&gt;﹏&lt;</em>)′   <a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">Windows系统Git安装教程-博客园 (cnblogs.com)</a></p>
<h1>nvm安装配置</h1>
<p>推荐使用NodeJs的版本管理工具nvm，安装node更容易，允许多个node版本共存，切换方便。</p>
<p><strong>完全卸载NodeJS</strong> ：</p>
<ol>
<li>控制面板卸载NodeJS，更推荐使用Geek Uninstaller和Wise Program Uninstaller</li>
<li>重启任务管理器，鲨掉所有与node有关进程。</li>
<li>删掉 <code>C:\Users\admin\.npmrc</code> 文件</li>
<li>寻找以下目录删掉
<ul>
<li>C:\Program Files (x86)\nodejs</li>
<li>C:\Program Files\nodejs</li>
<li>C:\Users\用户名\AppData\Roaming\npm</li>
<li>C:\Users\用户名\AppData\Roaming\npm-cache</li>
</ul>
</li>
<li>删有关node的环境变量。</li>
</ol>
<p><strong>下载安装nvm</strong>：</p>
<p>下载前确定node已经卸载干净。到<a href="https://github.com/coreybutler/nvm-windows/releases">github.com</a> 该网址的下载nvm-setup.zip或nvm-setup.exe</p>
<p>双击安装exe，一路猛戳下一步，默认下载到 <code>C:\Users\用户\AppData\Roaming\nvm</code></p>
<blockquote>
<p>安装好nvm后，由于国内下载速度慢，所以使用淘宝镜像。在nvm安装目录下找到settings.txt文件。在最后面回车加上：</p>
<p>node_mirror: <a href="http://npm.taobao.org/mirrors/node/">http://npm.taobao.org/mirrors/node/</a></p>
<p>npm_mirror: <a href="https://npm.taobao.org/mirrors/npm/">https://npm.taobao.org/mirrors/npm/</a></p>
</blockquote>
<p><strong>nvm常用命令</strong> ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvm list   				看本地有哪些版本NodeJs，正在使用的NodeJs会用*号标识</span><br><span class="line">nvm list available    		看网上有哪些可以下载的node版本</span><br><span class="line">nvm install 16.16.0    		下载16.16.0版本的NodeJs到nvm安装目录</span><br><span class="line">nvm uninstall 16.16.0  		 卸载16。16.0的NodeJs    </span><br><span class="line">nvm use 16.16.0   使用node    </span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="https://blog.csdn.net/lewky_liu/article/details/87959839">Windows完全卸载node.js并安装node.js的多版本管理工具nvm</a></p>
<h1>NodeJS</h1>
<p><strong>NodeJS介绍</strong>：简称 <code>node</code> ，类似后端语言的JavaScript环境，本质上是浏览器底层，自带的包管理器npm在前端能充当Maven一样的角色。</p>
<p><strong>node版本</strong>：2022年Hexo要求<u>Node版本必须14以上</u>，推荐16或18，太高或者太低都不好。 另外，Node版本选双不选单。</p>
<p><strong>下载安装</strong>： 直接用nvm下载node</p>
<blockquote>
<p>切换node或是<code>nvm use 16.16.0</code> 之前，需要先把<code>C:\Users\用户\.npmrc</code> 文件删掉，就像之前的卸载node一样。</p>
<p>再执行以下命令</p>
<p>npm cache clean --force                  清理缓存</p>
<p>npm config set registry <a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a>       node使用淘宝代理链接</p>
<p>npm config set cache “C:\Users\用户\AppData\Roaming\nvm\v版本号\node_cache”     node_cache文件夹没有则新建</p>
<p>npm config set prefix “C:\Users\用户\AppData\Roaming\nvm\v版本号\node_global”      node_global文件夹没有则新建</p>
</blockquote>
<p><strong>node和npm常用命令</strong> ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v    		看node版本</span><br><span class="line">npm -v    		看npm版本</span><br><span class="line">npm config list   			看npm配置项    </span><br><span class="line">npm config get registry     看是否在使用淘宝代理链接</span><br><span class="line">npm install 某           下载某依赖</span><br><span class="line">npm uninstall 某 -g       全局下载某依赖    </span><br><span class="line">npm uninstall 某  		卸载某依赖    </span><br></pre></td></tr></table></figure>
<p>参考链接：跳转前可以给我点一个赞吗，拜托拜托`(<em>&gt;﹏&lt;</em>)′  <a href="https://blog.csdn.net/Kenvinxu/article/details/106053210">https://blog.csdn.net/Kenvinxu/article/details/106053210</a></p>
<p>官网版本：<a href="https://nodejs.org/zh-cn/download/releases/">以往的版本 | Node.js (nodejs.org)</a></p>
<h1>Hexo搭建博客</h1>
<p>以下命令都在<u>管理员身份</u>的 <code>GitBash</code> 中敲</p>
<p><strong>本地生成博客文件，并访问</strong> ：</p>
<p>先找一个存博客的目录，新建目录blog，进去打开GitBash。再执行以下命令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli      	  	  npm全局安装hexo</span><br><span class="line">hexo init							初始化目录，生成一堆乱七八糟的文件和文件夹</span><br><span class="line">hexo s								本地运行，本地访问，默认端口<span class="number">4000</span>， 地址是http:<span class="comment">//localhost:4000/    </span></span><br><span class="line">Ctrl+C								取消运行</span><br><span class="line">hexo n <span class="string">&quot;第一篇MarkDown格式的博客&quot;</span>      	在blog下source\_posts下，用typora等md编辑软件编辑，随便写点字，写点格式进去</span><br><span class="line">hexo clean 			 				清理</span><br><span class="line">hexo g 						    	生成静态文件   </span><br></pre></td></tr></table></figure>
<p><strong>GitHub托管博客，所有人都可以访问</strong> ：</p>
<blockquote>
<p>Github创建一个新的public仓库    <a href="http://xn--GitHub-on9im33ani7axo6bfb0c.github.io">你的GitHub账户名.github.io</a>     严格要求是这个名字</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git 				#在blog目录下安装git部署插件 </span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置Hexo配置文件_config.yml， 在blog目录下</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">	type: git</span><br><span class="line">    repo: https:<span class="comment">//github.com/你的GitHub账户名/你的GitHub账户名.github.io.git</span></span><br><span class="line">	branch: master</span><br><span class="line">注意：冒号后面有空格的！！ 如果懒得注意，建议直接复制        </span><br></pre></td></tr></table></figure>
<blockquote>
<p>部署博客到 GitHub，就可以远程访问了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo d         部署</span><br><span class="line">或者</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d      清理缓存+生成静态文件+部署        </span><br></pre></td></tr></table></figure>
<p><code>https://你的GitHub账户名.github.io</code>  大功告成！ 这就是你的博客了</p>
<p><strong>注意点</strong>：</p>
<ol>
<li>报错，可能是没有以<strong>管理员模式</strong>打开<code>GitBash</code> ，有时候一些让人生气的bug，就是这种细节，知道是这个原因之后，更让人生气了！</li>
<li>部署不上GitHub，以下解决办法，都可以试试
<ul>
<li>改<code>repo</code> 后面的为 <code>git@github.com:你的GitHub账户名/你的GitHub账户名.github.io.git</code></li>
<li>改<code>branch</code>值为 <code>main</code></li>
<li>网太烂了，拨打10086升级宽带</li>
<li>单纯连不上GitHub，寻求周围 程序猿/媛 帮助</li>
</ul>
</li>
<li>Git 没绑定 GitHub 账号，查看前文Git安装配置</li>
</ol>
<h1>Butterfly主题</h1>
<p>进到Hexo博客根目录，打开GitBash，下载 <code>Butterfly</code> 主题 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>
<p>改Hexo博客根目录下的 <code>_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span></span><br><span class="line"><span class="string">改为</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure>
<p>清理缓存、生成静态文件、部署到 <code>GitHub</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p><strong>主题美化</strong></p>
<blockquote>
<p>官网权威文档：<a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安裝文檔(一) 快速開始 | Butterfly</a></p>
<p>参考链接：<a href="https://blog.csdn.net/weixin_44186409/article/details/106256493">butterfly主题修改_bt-sonny的博客</a></p>
<p><a href="https://blog.csdn.net/Brad_PiTt7/article/details/125712874">Hexo 个人博客搭建完整版</a></p>
</blockquote>
<h1>图床存图片，哪哪都能看</h1>
<p>本人使用 <code>Typora</code> 编辑Markdown文档来上传到博客，但本地图片上传到GitHub博客，就没法看了，为此寻找了多种方法。 最后选择了阿里云OSS存储作为图床，<code>PicGo</code>软件上传，<code>Typora</code>引用网址的方式</p>
<h2 id="1、本地同名文件夹引用，失效"><a class="header-anchor" href="#1、本地同名文件夹引用，失效">¶</a>1、本地同名文件夹引用，失效</h2>
<ol>
<li>下载处理图片的插件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br><span class="line">或</span><br><span class="line">npm install hexo-asset-img --save    </span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>在Hexo配置文件将配置项post_asset_folder设为true</p>
</li>
<li>
<p>设置Typora放图片的方式，自动把图片放到同名文件夹下</p>
</li>
</ol>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212062229102.png" alt="image-20221206222940084" style="zoom:80%;" />
<ol start="4">
<li>执行命令 <code>hexo new article_name</code>，在source/_posts中会生成文章article_name.md和同名文件夹article_name。将图片资源放在article_name文件夹中，文章就可以使用相对路径引用图片资源了。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">![可选图片描述](文章名/图片名.png)  </span><br></pre></td></tr></table></figure>
<h2 id="2、GitHub图床，失效"><a class="header-anchor" href="#2、GitHub图床，失效">¶</a>2、GitHub图床，失效</h2>
<ul>
<li>登录自己的github，建立一个<strong>公开</strong>的仓库，用于存储图片</li>
<li>进入personal settings -&gt; developer settings -&gt; personal access tokens -&gt; generate new token</li>
</ul>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212062237974.png" alt="image-20221206223720588" style="zoom:80%;" />
<ul>
<li>生成token信息，及时复制出现的token</li>
<li>下载Windows的PicGo的exe文件，如PicGo-Setup-2.3.0-x64.exe，  链接：<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></li>
<li>设置PicGo，开启<strong>时间戳重命名</strong>。</li>
</ul>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212062240680.png" alt="image-20221206224009940" style="zoom:80%;" />
<ul>
<li>Typora设置</li>
</ul>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212062241782.png" alt="image-20221206224141673" style="zoom:80%;" />
<ul>
<li>点击<strong>验证图片上传选项</strong> ，看到success就大功告成！</li>
</ul>
<h2 id="3、Gitee图床，失效"><a class="header-anchor" href="#3、Gitee图床，失效">¶</a>3、Gitee图床，失效</h2>
<p><u>设置方式和GitHub图床类似</u></p>
<p><strong>在不好用这方面，和GitHub图床类似，水平十分接近。 Gitee网速稍微快一点</strong></p>
<p>Typora把图片给PicGo，PicGo用于上传，Gitee仓库用于存放图片。</p>
<ul>
<li>GitHub单仓库1Gb~5GB，单文件最大100MB</li>
<li>Gitee单仓库最大500MB，单文件最大50M，总仓库5GB；</li>
</ul>
<blockquote>
<p>Gitee用于图床的个人密钥：xxxxxxxxxxx ， 被PicGo用于上传图片，让Gitee知道是自己人。 但查看图片不限于自己人<br>
<code>https://gitee.com/码云账户名/仓库名/raw/master/</code> 图片存时，前缀地址<br>
图片每次都会暂时存在<code>C:/Users/用户/AppData/Roaming/Typora/typora-user-images</code>， 害怕它会越存越大，解决办法是：先保存在./pictures下，需要时再上传到图床。<br>
可以一次性上传所有本地pictures， “格式” -&gt; “图像” -&gt; “上传所有本地图片” （不用担心上传几百张，它只上传当下folder的pictures</p>
</blockquote>
<p>参考链接：<a href="https://cloud.tencent.com/developer/article/1801576">https://cloud.tencent.com/developer/article/1801576</a></p>
<h2 id="4、阿里云OSS图床，最终方案"><a class="header-anchor" href="#4、阿里云OSS图床，最终方案">¶</a>4、阿里云OSS图床，最终方案</h2>
<h3 id="4-1-开通OSS对象存储"><a class="header-anchor" href="#4-1-开通OSS对象存储">¶</a>4.1 开通OSS对象存储</h3>
<p>在阿里云官网OSS <a href="https://www.aliyun.com/product/oss">对象存储OSS_云存储服务_-阿里云 (aliyun.com)</a> 点击 “立即开通”</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212070032355.png" alt="image-20221206233659678" style="zoom:80%;" />
<p>注册账户，实名。  （如果是新用户，还可以超低价买云服务器，可以用来练习Linux命令、部署网站等）</p>
<p>点击oss页面 “管理控制台”</p>
<h3 id="4-2-创建Bucket"><a class="header-anchor" href="#4-2-创建Bucket">¶</a>4.2 创建Bucket</h3>
<p>在<a href="https://oss.console.aliyun.com/bucket">OSS管理控制台 (aliyun.com)</a> 创建Bucket</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212070032356.png" alt="image-20221206234124640" style="zoom:80%;" />
<blockquote>
<ol>
<li>Bucket名称不能有大写字母，不能中文。 建议全小写英文，中间以<code>-</code>连接。如 <code>blog-img-oss</code></li>
<li>服务器选离自己近的</li>
<li>Endpoint默认，所属资源组默认</li>
<li>存储类型： <strong>标准存储</strong>（因为博客网所需流量和容量大，如果访问很少选<u>低频访问存储</u>）</li>
<li>读写权限： 一定要是<strong>公共读</strong>！ (私有别人看不了你图片，公共读写太危险)</li>
<li>其余的，都不听不要不开通！！ HDFS服务、冗余存储、版本控制、加密方式、日志查询、定时备份</li>
</ol>
</blockquote>
<p>复制你的地域节点，如<code>oss-cn-beijing</code> ，后面的 <code>.aliyuncs.com</code> 不复制。</p>
<h3 id="4-3-复制AccessKey和AccessKeySecret"><a class="header-anchor" href="#4-3-复制AccessKey和AccessKeySecret">¶</a>4.3 复制AccessKey和AccessKeySecret</h3>
<p>依次点击 <u>头像</u> -&gt; AccessKey管理 -&gt; 继续使用AccessKey -&gt; 创建AccessKey</p>
<p>一系列操作后，复制你的<code>accessKeyId</code>和<code>accessKeySecret</code></p>
<p><img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212070004317.png" alt=""></p>
<h3 id="4-4-充钱"><a class="header-anchor" href="#4-4-充钱">¶</a>4.4 充钱</h3>
<p>见名知意，阿里云首页-&gt;费用</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212070008232.png" alt="image-20221207000842470" style="zoom:80%;" />
<p>主要分容量和流量(流入/留出)，费用很便宜</p>
<ul>
<li>容量：0.12元/GB/月</li>
<li>图片<strong>上传</strong>到阿里OSS流量：免费</li>
<li>用户查看你的博客图片，<strong>流出</strong>流量： 闲时<u>0.25元/GB</u>，忙时<u>0.50元/GB</u></li>
</ul>
<h3 id="4-5-PicGo图床设置"><a class="header-anchor" href="#4-5-PicGo图床设置">¶</a>4.5 PicGo图床设置</h3>
<p>刚复制的那些内容派上用场了，点击确定，设为默认图床。</p>
<p>PicGo设置开启 “时间戳重命名”</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212070016467.png" alt="image-20221207001600070" style="zoom:80%;" />
<h3 id="4-6-Typora设置"><a class="header-anchor" href="#4-6-Typora设置">¶</a>4.6 Typora设置</h3>
<p>验证成功，直接在Typora粘贴图片，自动由PicGo上传到OSS。</p>
<p>图片链接如：<a href="https://xn--Bucket-on9im33a.xn--6qq04ao0deyay3ll6f.aliyuncs.com/%E4%BD%A0%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84/%E5%9B%BE%E7%89%87%E5%90%8D">https://你Bucket名.你存储区域名.aliyuncs.com/你存储路径/图片名</a></p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212070022192.png" alt="image-20221207002129577" style="zoom:80%;" />
<h1>百度/谷歌收录网站</h1>
<p>好累，不打字了，看看我辛苦找的其他文章吧</p>
<p>参考链接：  跳转前可以给我点一个赞吗，拜托拜托`(<em>&gt;﹏&lt;</em>)′</p>
<p><a href="https://www.ancii.com/avcwpl4d6/">搭建Hexo博客进阶篇–API和一些小部件</a></p>
<p><a href="https://yogwang.site/2020/How-to-make-GithubPage-included-by-Baidu/">https://yogwang.site/2020/How-to-make-GithubPage-included-by-Baidu/</a></p>
<h1>注意点</h1>
<h2 id="1-主题配置文件和Hexo配置文件的区别"><a class="header-anchor" href="#1-主题配置文件和Hexo配置文件的区别">¶</a>1. 主题配置文件和Hexo配置文件的区别</h2>
<ul>
<li>Hexo配置文件： 主配置文件，只有一个，blog目录下 <code>_config.yml</code></li>
<li>主题配置文件： 每种主题都有一个， blog目录下 <code>themes\主题名\_config.yml</code></li>
</ul>
<h2 id="2-常用图片放本地，并压缩"><a class="header-anchor" href="#2-常用图片放本地，并压缩">¶</a>2. 常用图片放本地，并压缩</h2>
<p>类似于avatar头像，图片favicon.png，背景图片这样的，就别放阿里云OSS了，流量伤不起呀，当然土豪当我没说。</p>
<p>推荐图片压缩软件：<a href="https://www.fosshub.com/Caesium-Image-Compressor.html">Caesium Image Compressor</a></p>
<p>推荐图片压缩网站：<a href="https://tinypng.com/">TinyPNG – Compress WebP, PNG and JPEG images intelligently</a></p>
<h2 id="3-npm全局安装"><a class="header-anchor" href="#3-npm全局安装">¶</a>3. npm全局安装</h2>
<p>配置前，全局下载在</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\用户名\AppData\Roaming\npm</span><br></pre></td></tr></table></figure>
<p>配置后，全局下载的在</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\admin\AppData\Roaming\nvm\v18.12.0\node_global</span><br></pre></td></tr></table></figure>
<p>当使用 <code>npm install hexo-asset-img --save</code> 这类带 <code>--save</code>的命令，不要再加上<code>-g</code> 全局安装</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Tutorial</tag>
        <tag>GitHub</tag>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>Git配置+GitHub绑定</title>
    <url>/articles/Git%E9%85%8D%E7%BD%AE+GitHub%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h1>Git安装配置，绑定GitHub账号</h1>
<p><strong>下载</strong>：搜索Git官网，下载64位setup，如Git-2.32.0-64-bit.exe</p>
<p><strong>安装</strong> ：无脑下一步，Git Bash是Git的命令行，如果选了只GitBash，那在cmd中使用git会报’git’ 不是内部或外部命令，解决办法是把Git安装文件夹下bin目录、git-core加入到环境变量中。</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212061915388.png" alt="image-20221206191429644" style="zoom:80%;" />
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212071100043.png" alt="image-20221206191639793" style="zoom:80%;" />
<p><strong>设置用户全局签名</strong> ： 会记录在 <code>C:\users\用户\.gitconfig</code>里面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;账户名&quot;</span>       账户名随便写几个字母</span><br><span class="line">git config --global user.email <span class="string">&quot;邮箱地址&quot;</span>     邮箱随便写，瞎写都行。</span><br><span class="line">git config --global --<span class="built_in">list</span>				查看写对了吗    </span><br></pre></td></tr></table></figure>
<p><strong>配置Git绑定GitHub</strong>：</p>
<p>鼠标右键选GitBash，输入 <code>ssh-keygen -t rsa</code> ，显示overwrite时输入y，其他时候按三次回车。</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212062145500.png" alt="image-20221206214526322" style="zoom:80%;" />
<p>之后在<code>C:\Users\用户\.ssh</code>下，有一个rsa后缀的私钥文件，要严密保管。 有一个pub后缀的公钥文件，复制公钥的内容，到GitHub网站你头像下面settings -&gt; SSH and GPG keys -&gt; new SSH key，Title随便写，Key部分填你的公钥内容。</p>
<p>在 <code>GitBash</code> 中输入 <code>ssh -T git@github.com</code> ，看到有successfully就说明绑定好了。</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212062146968.png" alt="image-20221206214628634" style="zoom:80%;" />
<p>参考链接：跳转前可以给我点一个赞吗，拜托拜托`(<em>&gt;﹏&lt;</em>)′   <a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">Windows系统Git安装教程-博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>Tool</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Tutorial</tag>
        <tag>GitHub</tag>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Butterfly搭建博客</title>
    <url>/articles/Hexo+Butterfly%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1>Hexo搭建博客</h1>
<p>以下命令都在<u>管理员身份</u>的 <code>GitBash</code> 中敲</p>
<p><strong>本地生成博客文件，并访问</strong> ：</p>
<p>先找一个存博客的目录，新建目录blog，进去打开GitBash。再执行以下命令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli      	  	  npm全局安装hexo</span><br><span class="line">hexo init							初始化目录，生成一堆乱七八糟的文件和文件夹</span><br><span class="line">hexo s								本地运行，本地访问，默认端口<span class="number">4000</span>， 地址是http:<span class="comment">//localhost:4000/    </span></span><br><span class="line">Ctrl+C								取消运行</span><br><span class="line">hexo n <span class="string">&quot;第一篇MarkDown格式的博客&quot;</span>      	在blog下source\_posts下，用typora等md编辑软件编辑，随便写点字，写点格式进去</span><br><span class="line">hexo clean 			 				清理</span><br><span class="line">hexo g 						    	生成静态文件   </span><br></pre></td></tr></table></figure>
<p><strong>GitHub托管博客，所有人都可以访问</strong> ：</p>
<blockquote>
<p>Github创建一个新的public仓库    <a href="http://xn--GitHub-on9im33ani7axo6bfb0c.github.io">你的GitHub账户名.github.io</a>     严格要求是这个名字</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git 				#在blog目录下安装git部署插件 </span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置Hexo配置文件_config.yml， 在blog目录下</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">	type: git</span><br><span class="line">    repo: https:<span class="comment">//github.com/你的GitHub账户名/你的GitHub账户名.github.io.git</span></span><br><span class="line">	branch: master</span><br><span class="line">注意：冒号后面有空格的！！ 如果懒得注意，建议直接复制        </span><br></pre></td></tr></table></figure>
<blockquote>
<p>部署博客到 GitHub，就可以远程访问了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo d         部署</span><br><span class="line">或者</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d      清理缓存+生成静态文件+部署        </span><br></pre></td></tr></table></figure>
<p><code>https://你的GitHub账户名.github.io</code>  大功告成！ 这就是你的博客了</p>
<p><strong>注意点</strong>：</p>
<ol>
<li>报错，可能是没有以<strong>管理员模式</strong>打开<code>GitBash</code> ，有时候一些让人生气的bug，就是这种细节，知道是这个原因之后，更让人生气了！</li>
<li>部署不上GitHub，以下解决办法，都可以试试
<ul>
<li>改<code>repo</code> 后面的为 <code>git@github.com:你的GitHub账户名/你的GitHub账户名.github.io.git</code></li>
<li>改<code>branch</code>值为 <code>main</code></li>
<li>网太烂了，拨打10086升级宽带</li>
<li>单纯连不上GitHub，寻求周围 程序猿/媛 帮助</li>
</ul>
</li>
<li>Git 没绑定 GitHub 账号，查看前文Git安装配置</li>
</ol>
<h1>Butterfly主题</h1>
<p>进到Hexo博客根目录，打开GitBash，下载 <code>Butterfly</code> 主题 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>
<p>改Hexo博客根目录下的 <code>_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span></span><br><span class="line"><span class="string">改为</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure>
<p>清理缓存、生成静态文件、部署到 <code>GitHub</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p><strong>主题美化</strong></p>
<blockquote>
<p>官网权威文档：<a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安裝文檔(一) 快速開始 | Butterfly</a></p>
<p>参考链接：<a href="https://blog.csdn.net/weixin_44186409/article/details/106256493">butterfly主题修改_bt-sonny的博客</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Tool</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Tutorial</tag>
        <tag>GitHub</tag>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA中三种方式实现SpringBoot热部署</title>
    <url>/articles/IDEA%E4%B8%AD%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0SpringBoot%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p><strong>概述</strong>：热部署(HotSwap)也叫热加载、热更新、热替换，它避免了少量代码更改而带来的避免重启时间，在大型项目中尤其有用，三个实现<code>SpringBoot</code>热部署方法，配合IDEA使用。</p>
<ul>
<li><code>dev-tools</code>可以实现大部分代码的热部署，但是和数据库连接池有冲突，容易造成数据库连接池关闭。</li>
<li><code>JRebel</code>需要用网络注册，无网环境配置不太行。</li>
<li><code>HotSwap</code> 插件IDEA自带，有时不太生效。</li>
</ul>
<h1>总</h1>
<h2 id="Dev-tools-推荐"><a class="header-anchor" href="#Dev-tools-推荐">¶</a>Dev-tools(推荐)</h2>
<p><code>spring-boot-devtools</code> 是 Spring Boot 提供的<a href="https://cloud.tencent.com/product/cclid?from=10680">开发者工具</a>，它会监控当前应用所在的 classpath 下的文件发生变化，进行<strong>自动重启</strong>。</p>
<p>注： dev-tools并不是热部署，而是一种<strong>较快的重启方式</strong> 。</p>
<h3 id="引入Maven依赖"><a class="header-anchor" href="#引入Maven依赖">¶</a>引入Maven依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这是spring boot devtool plugin 热部署1常用，如果不添加似乎也可以运行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="配置yaml"><a class="header-anchor" href="#配置yaml">¶</a>配置yaml</h3>
<p>在<code>application.yaml</code>或<code>application.yml</code> 配置，如果是.properties需自行转换</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">devtools</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">restart</span>:<span class="string"></span></span><br><span class="line"><span class="comment">            #热部署生效</span></span><br><span class="line">          <span class="attr">enabled</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">            #设置重启的目录</span></span><br><span class="line"><span class="comment">            #additional-paths: src/main/java</span></span><br><span class="line"><span class="comment">            #classpath目录下的WEB-INF文件夹内容修改不重启</span></span><br><span class="line">          <span class="attr">exclude</span>: <span class="string">WEB-INF/**</span></span><br></pre></td></tr></table></figure>
<p>到这里就已经可以了，如果项目代码更改，在项目使用Debug模式启动下，只需要在IDEA上方 Build-&gt;Build Project即可（快捷键为 Ctrl+F9）</p>
<p>如果这一步也想省掉，执行以下步骤。</p>
<h3 id="自动编译"><a class="header-anchor" href="#自动编译">¶</a>自动编译</h3>
<p>打开IDEA设置，在<code>Compiler</code> 选项卡，将 <code>Build project automatically</code> 勾选</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212222330997.png" alt="image-20221222233042106" style="zoom:80%;" />
<p>此时dev-tools限定在Debug模式下启动项目，如果想要Run模式也能使用dev-tools，<code>Ctrl+Shift+Alt+/</code> ，勾选Registry下的<code>Compiler autoMake allow when app running</code></p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212222335867.png" alt="image-20221222233549082" style="zoom:80%;" />
<hr>
<h2 id="JRebel"><a class="header-anchor" href="#JRebel">¶</a>JRebel</h2>
<p>一款知名的Java热部署插件</p>
<h3 id="IDEA安装JRebel插件"><a class="header-anchor" href="#IDEA安装JRebel插件">¶</a>IDEA安装JRebel插件</h3>
<p>在idea的settings -&gt; Marketspace -&gt; 搜索jrebel -&gt; 下载<code>JRebel and XRebel for IntelliJ</code></p>
<h3 id="在线GUID地址：在线生成GUID"><a class="header-anchor" href="#在线GUID地址：在线生成GUID">¶</a>在线GUID地址：在线生成GUID</h3>
<p>在 <a href="https://www.guidgen.com/">https://www.guidgen.com/</a> 生成GUID后， 服务器地址为 <code>https://jrebel.qekang.com/&#123;GUID&#125;</code></p>
<h3 id="打开JRebel"><a class="header-anchor" href="#打开JRebel">¶</a>打开JRebel</h3>
<p>选择<code>Connect to online licensing service</code></p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212222342051.png" alt="image-20221222234157794" style="zoom:80%;" />
<p>以后通过<code>JRebel</code>启动项目即可</p>
<h3 id="设置离线模式"><a class="header-anchor" href="#设置离线模式">¶</a>设置离线模式</h3>
<p>在IDEA中 <code>settings -&gt; JRebel &amp; XRebel -&gt; 点击Work offline</code></p>
<h3 id="自动编译-v2"><a class="header-anchor" href="#自动编译-v2">¶</a>自动编译</h3>
<p>同Dev-tools的自动编译</p>
<h2 id="HotSwap"><a class="header-anchor" href="#HotSwap">¶</a>HotSwap</h2>
<p>IDEA自带的插件，而且与<code>dev-tools</code>不兼容，需去除dev的依赖。</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212222348943.png" alt="image-20221222234756047" style="zoom:80%;" />
<p>使用和自动编译同Dev-tools。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>devtools</tag>
        <tag>jrebel</tag>
        <tag>idea</tag>
        <tag>SpringBoot</tag>
        <tag>热部署</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM垃圾回收算法+典型垃圾回收器</title>
    <url>/articles/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95+%E5%85%B8%E5%9E%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    <content><![CDATA[<p>JVM去完成Java的垃圾回收，今天，笔者我介绍一下JVM进行垃圾回收的各种算法。</p>
<ul>
<li><a href="#1-%e5%a6%82%e4%bd%95%e7%a1%ae%e5%ae%9a%e6%9f%90%e4%b8%aa%e5%af%b9%e8%b1%a1%e6%98%af%e5%9e%83%e5%9c%be">1. 如何确定某个对象是垃圾</a>
<ul>
<li><a href="#11-%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0%e6%b3%95">1.1. 引用计数法</a></li>
<li><a href="#12-%e5%8f%af%e8%be%be%e6%80%a7%e5%88%86%e6%9e%90">1.2. 可达性分析</a></li>
</ul>
</li>
<li><a href="#2-%e5%85%b8%e5%9e%8b%e7%9a%84%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e7%ae%97%e6%b3%95">2. 典型的垃圾回收算法</a>
<ul>
<li><a href="#21-%e6%a0%87%e8%ae%b0-%e6%b8%85%e9%99%a4%e7%ae%97%e6%b3%95mark-sweep">2.1. 标记-清除算法(Mark-Sweep)</a></li>
<li><a href="#22-%e5%a4%8d%e5%88%b6%e7%ae%97%e6%b3%95copying">2.2. 复制算法(Copying)</a></li>
<li><a href="#23-%e6%a0%87%e8%ae%b0-%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95mark-compact">2.3. 标记-整理算法(Mark-Compact)</a></li>
<li><a href="#24-%e5%88%86%e4%bb%a3%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95generational-collection">2.4. 分代收集算法(Generational Collection)</a></li>
</ul>
</li>
<li><a href="#3-%e5%85%b8%e5%9e%8b%e7%9a%84%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8">3. 典型的垃圾收集器</a>
<ul>
<li><a href="#31-serialserial-old">3.1. Serial/Serial Old</a></li>
<li><a href="#32-parnew">3.2. ParNew</a></li>
<li><a href="#33-parallel-scavenge">3.3. Parallel Scavenge</a></li>
<li><a href="#34-parallel-old">3.4. Parallel Old</a></li>
<li><a href="#35-cms">3.5. CMS</a></li>
<li><a href="#36-g1">3.6. G1</a></li>
</ul>
</li>
<li><a href="#4-%e5%8f%82%e8%80%83%e6%96%87%e7%ab%a0">4. 参考文章</a></li>
</ul>
<h1>1. 如何确定某个对象是垃圾</h1>
<h2 id="1-1-引用计数法"><a class="header-anchor" href="#1-1-引用计数法">¶</a>1.1. 引用计数法</h2>
<p>在Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用，则说明对象不太可能再被用到，那么这个对象就是可回收对象。这种方式即是引用计数法。这种方式的问题是无法解决循环引用的问题，举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Object object1=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    Object object2=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    object1.object=object2;</span><br><span class="line">    object2.object=object1;</span><br><span class="line">    object1=<span class="literal">null</span>;</span><br><span class="line">    object2=<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，在最后，object1和object2的内存块都不能再被访问到了，但他们的引用计数都不为0，这就会使他们永远不会被清除。</p>
<h2 id="1-2-可达性分析"><a class="header-anchor" href="#1-2-可达性分析">¶</a>1.2. 可达性分析</h2>
<p>为了解决引用计数法的循环引用问题，Java使用了可达性分析的方法。通过一系列的&quot;GC roots&quot;对象作为起点搜索。如果在&quot;GC roots&quot;和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。</p>
<p>所谓&quot;GC roots&quot;，或者说tracing GC的&quot;根集合&quot;，就是一组必须活跃的引用。例如说，这些引用可能包括：</p>
<ul>
<li>所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。</li>
<li>VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。</li>
<li>JNI handles，包括global handles和local handles（看情况）</li>
<li>所有当前被加载的Java类（看情况）</li>
<li>Java类的引用类型静态变量（看情况）</li>
<li>Java类的运行时常量池里的引用类型常量（String或Class类型）（看情况）</li>
<li>String常量池（StringTable）里的引用</li>
</ul>
<p>比较常见的将对象视为可回收对象的原因：</p>
<ul>
<li>显式地将对象的唯一强引用指向新的对象。</li>
<li>显式地将对象的唯一强引用赋值为Null。</li>
<li>局部引用所指向的对象（如，方法内对象）。</li>
</ul>
<p>下述代码中，每次循环结束，object都会被视为可回收对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i</span><br></pre></td></tr></table></figure>
<ul>
<li>只有弱引用与其关联的对象</li>
</ul>
<h1>2. 典型的垃圾回收算法</h1>
<p>在JVM规范中并没有明确GC的运作方式，各个厂商可以采用不同的方式去实现垃圾回收器。这里讨论几种常见的GC算法。</p>
<h2 id="2-1-标记-清除算法-Mark-Sweep"><a class="header-anchor" href="#2-1-标记-清除算法-Mark-Sweep">¶</a>2.1. 标记-清除算法(Mark-Sweep)</h2>
<p>最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。如图：</p>
<p><img src="https://images2015.cnblogs.com/blog/989246/201704/989246-20170406161514082-1220415753.jpg" alt=""></p>
<p>从图中我们就可以发现，该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。</p>
<h2 id="2-2-复制算法-Copying"><a class="header-anchor" href="#2-2-复制算法-Copying">¶</a>2.2. 复制算法(Copying)</h2>
<p>为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图：</p>
<p><img src="https://images2015.cnblogs.com/blog/989246/201704/989246-20170406162053957-592638524.jpg" alt=""></p>
<p>这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying算法的效率会大大降低。</p>
<h2 id="2-3-标记-整理算法-Mark-Compact"><a class="header-anchor" href="#2-3-标记-整理算法-Mark-Compact">¶</a>2.3. 标记-整理算法(Mark-Compact)</h2>
<p>结合了以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。如图：</p>
<p><img src="https://images2015.cnblogs.com/blog/989246/201704/989246-20170406162848519-1635773526.jpg" alt=""></p>
<h2 id="2-4-分代收集算法-Generational-Collection"><a class="header-anchor" href="#2-4-分代收集算法-Generational-Collection">¶</a>2.4. 分代收集算法(Generational Collection)</h2>
<p>分代收集法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将GC堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</p>
<p>目前大部分JVM的GC对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。一般将新生代划分为一块较大的Eden空间和两个较小的Survivor空间(From Space, To Space)，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor空间中。</p>
<p><img src="https://images2015.cnblogs.com/blog/989246/201704/989246-20170406170311707-1412704605.jpg" alt=""></p>
<p>而老生代因为每次只回收少量对象，因而采用Mark-Compact算法。</p>
<p>另外，不要忘记在<a href="http://www.cnblogs.com/cielosun/p/6622983.html">Java基础：Java虚拟机(JVM)</a>中提到过的处于方法区的永生代(Permanet Generation)。它用来存储class类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。</p>
<p>对象的内存分配主要在新生代的Eden Space和Survivor Space的From Space(Survivor目前存放对象的那一块)，少数情况会直接分配到老生代。当新生代的Eden Space和From Space空间不足时就会发生一次GC，进行GC后，Eden Space和From Space区的存活对象会被挪到To Space，然后将Eden Space和From Space进行清理。如果To Space无法足够存储某个对象，则将这个对象存储到老生代。在进行GC后，使用的便是Eden Space和To Space了，如此反复循环。当对象在Survivor区躲过一次GC后，其年龄就会+1。默认情况下年龄到达15的对象会被移到老生代中。</p>
<h1>3. 典型的垃圾收集器</h1>
<p>垃圾收集算法是垃圾收集器的理论基础，而垃圾收集器就是其具体实现。下面介绍HotSpot虚拟机提供的几种垃圾收集器。</p>
<h2 id="3-1-Serial-Serial-Old"><a class="header-anchor" href="#3-1-Serial-Serial-Old">¶</a>3.1. Serial/Serial Old</h2>
<p>最古老的收集器，是一个单线程收集器，用它进行垃圾回收时，必须暂停所有用户线程。Serial是针对新生代的收集器，采用Copying算法；而Serial Old是针对老生代的收集器，采用Mark-Compact算法。优点是简单高效，缺点是需要暂停用户线程。</p>
<h2 id="3-2-ParNew"><a class="header-anchor" href="#3-2-ParNew">¶</a>3.2. ParNew</h2>
<p>Seral/Serial Old的多线程版本，使用多个线程进行垃圾收集。</p>
<h2 id="3-3-Parallel-Scavenge"><a class="header-anchor" href="#3-3-Parallel-Scavenge">¶</a>3.3. Parallel Scavenge</h2>
<p>新生代的并行收集器，回收期间不需要暂停其他线程，采用Copying算法。该收集器与前两个收集器不同，主要为了达到一个可控的吞吐量。</p>
<h2 id="3-4-Parallel-Old"><a class="header-anchor" href="#3-4-Parallel-Old">¶</a>3.4. Parallel Old</h2>
<p>Parallel Scavenge的老生代版本，采用Mark-Compact算法和多线程。</p>
<h2 id="3-5-CMS"><a class="header-anchor" href="#3-5-CMS">¶</a>3.5. CMS</h2>
<p>Current Mark Sweep收集器是一种以最小回收时间停顿为目标的并发回收器，因而采用Mark-Sweep算法。</p>
<h2 id="3-6-G1"><a class="header-anchor" href="#3-6-G1">¶</a>3.6. G1</h2>
<p>G1(Garbage First)收集器技术的前沿成果，是面向服务端的收集器，能充分利用CPU和多核环境。是一款并行与并发收集器，它能够建立可预测的停顿时间模型。</p>
<h1>4. 参考文章</h1>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3783345.html">Java垃圾回收机制</a><br>
<a href="https://www.zhihu.com/question/53613423/answer/135743258">java的gc为什么要分代？ - RednaxelaFX的回答 - 知乎</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
        <category>GarbageCollect</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>GarbageCollect</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM常见参数+配置</title>
    <url>/articles/JVM%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0+%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>hello，今天分享一下JVM参数。</p>
<p><strong>堆配置：</strong></p>
<ul>
<li>-Xms:初始堆大小</li>
<li>-Xms：最大堆大小</li>
<li>-XX:NewSize=n:设置年轻代大小</li>
<li>-XX:NewRatio=n:设置年轻代和年老代的比值。如：为 3 表示年轻代和年老代比值为 1：3，年轻代占整个年轻代年老代和的 1/4</li>
<li>-XX:SurvivorRatio=n:年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。如 3 表示 Eden： 3 Survivor：2，一个 Survivor 区占整个年轻代的 1/5</li>
<li>-XX:MaxPermSize=n:设置持久代大小</li>
</ul>
<p><strong>收集器设置：</strong></p>
<ul>
<li>-XX:+UseSerialGC:设置串行收集器</li>
<li>-XX:+UseParallelGC:设置并行收集器</li>
<li>-XX:+UseParalledlOldGC:设置并行年老代收集器</li>
<li>-XX:+UseConcMarkSweepGC:设置并发收集器</li>
</ul>
<p><strong>并行收集器设置</strong></p>
<ul>
<li>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的 CPU 数。并行收集线程数</li>
<li>-XX:MaxGCPauseMillis=n:设置并行收集最大的暂停时间（如果到这个时间了，垃圾回收器依然没有回收完，也会停止回收）</li>
<li>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为：1/(1+n)</li>
<li>-XX:+CMSIncrementalMode:设置为增量模式。适用于单 CPU 情况</li>
<li>-XX:ParallelGCThreads=n:设置并发收集器年轻代手机方式为并行收集时，使用的 CPU 数。并行收集线程数</li>
</ul>
<p><strong>打印 GC 回收的过程日志信息</strong></p>
<ul>
<li>-XX:+PrintGC</li>
<li>-XX:+PrintGCDetails</li>
<li>-XX:+PrintGCTimeStamps</li>
<li>-Xloggc:filename</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java四种引用：强、软、弱、虚。</title>
    <url>/articles/Java%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%EF%BC%9A%E5%BC%BA%E3%80%81%E8%BD%AF%E3%80%81%E5%BC%B1%E3%80%81%E8%99%9A%E3%80%82/</url>
    <content><![CDATA[<h3 id="导读"><a class="header-anchor" href="#导读">¶</a>导读</h3>
<p><strong>本文的思路如以下：</strong></p>
<p><strong>（1）Java的四种对象引用的基本概念</strong></p>
<p><strong>（2）四种对象引用的差异对比</strong></p>
<p><strong>（3）对象可及性的判断以及与垃圾回收机制的关系</strong></p>
<h3 id="Java的四种对象引用的基本概念"><a class="header-anchor" href="#Java的四种对象引用的基本概念">¶</a>Java的四种对象引用的基本概念</h3>
<p>从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>
<h4 id="1、强引用"><a class="header-anchor" href="#1、强引用">¶</a>1、强引用</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object obj =new Object();</span><br></pre></td></tr></table></figure>
<p>上述Object这类对象就具有强引用，属于不可回收的资源，垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠回收具有强引用的对象，来解决内存不足的问题。</p>
<p>值得注意的是：如果想中断或者回收强引用对象，可以显式地将引用赋值为null，这样的话JVM就会在合适的时间，进行垃圾回收。</p>
<p>下图是堆区的内存示意图，分为新生代，老生代，而垃圾回收主要也是在这部分区域中进行。</p>
<img src="Java四种引用：强、软、弱、虚。/image-20230325014101165.png" alt="image-20230325014101165" style="zoom:80%;" />
<h4 id="2、软引用（SoftReference）"><a class="header-anchor" href="#2、软引用（SoftReference）">¶</a>2、软引用（SoftReference）</h4>
<p>如果一个对象只具有软引用，那么它的性质属于可有可无的那种。如果此时内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。</p>
<p>软引用可用来实现内存敏感的告诉缓存。软引用可以和一个引用队列联合使用，如果软件用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">        ReferenceQueue queue = new ReferenceQueue();</span><br><span class="line">        SoftReference reference = new SoftReference(obj, queue);</span><br><span class="line">        //强引用对象滞空，保留软引用</span><br><span class="line">        obj = null;</span><br></pre></td></tr></table></figure>
<p>当内存不足时，软引用对象被回收时，reference.get()为null，此时软引用对象的作用已经发挥完毕，这时将其添加进 <strong>ReferenceQueue 队列中</strong></p>
<p>如果要判断哪些软引用对象已经被清理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SoftReference ref = null;</span><br><span class="line">while ((ref = (SoftReference) queue.poll()) != null) &#123;</span><br><span class="line">//清除软引用对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、弱引用-WeakReference"><a class="header-anchor" href="#3、弱引用-WeakReference">¶</a>3、弱引用(WeakReference)</h4>
<p>如果一个对象具有弱引用，那其的性质也是可有可无的状态。</p>
<p>而弱引用和软引用的区别在于：弱引用的对象拥有更短的生命周期，只要垃圾回收器扫描到它，不管内存空间充足与否，都会回收它的内存。</p>
<p>同样的弱引用也可以和引用队列一起使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">        ReferenceQueue queue = new ReferenceQueue();</span><br><span class="line">        WeakReference reference = new WeakReference(obj, queue);</span><br><span class="line">        //强引用对象滞空，保留软引用</span><br><span class="line">        obj = null;</span><br></pre></td></tr></table></figure>
<h4 id="4、虚引用（PhantomReference）"><a class="header-anchor" href="#4、虚引用（PhantomReference）">¶</a>4、虚引用（PhantomReference）</h4>
<p>虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。</p>
<p>注意：虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。</p>
<p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">        ReferenceQueue queue = new ReferenceQueue();</span><br><span class="line">        PhantomReference reference = new PhantomReference(obj, queue);</span><br><span class="line">        //强引用对象滞空，保留软引用</span><br><span class="line">        obj = null;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="引用总结"><a class="header-anchor" href="#引用总结">¶</a>引用总结</h3>
<p>1.对于强引用，平时在编写代码时会经常使用。</p>
<p>2.而其他三种类型的引用，使用得最多就是软引用和弱引用，这两种既有相似之处又有区别，他们都来描述非必须对象。</p>
<p>3.被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。</p>
<img src="Java四种引用：强、软、弱、虚。/image-20230325014122959.png" alt="image-20230325014122959" style="zoom:80%;" />
<h3 id="四种对象引用的差异对比"><a class="header-anchor" href="#四种对象引用的差异对比">¶</a>四种对象引用的差异对比</h3>
<p>Java中4种引用的级别由高到低依次为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用</span><br></pre></td></tr></table></figure>
<p>垃圾回收时对比：<br>
<img src="Java四种引用：强、软、弱、虚。/image-20230325014135415.png" alt="image-20230325014135415" style="zoom:80%;" /></p>
<h3 id="对象可及性的判断"><a class="header-anchor" href="#对象可及性的判断">¶</a>对象可及性的判断</h3>
<p>在很多的时候，一个对象并不是从根集直接引用的，而是一个对象被其他对象引用，甚至同时被几个对象所引用，从而构成一个以根集为顶的树形结构。</p>
<img src="Java四种引用：强、软、弱、虚。/image-20230325014145744.png" alt="image-20230325014145744" style="zoom:80%;" />
<p>在这个树形的引用链中，箭头的方向代表了引用的方向，所指向的对象是被引用对象。由图可以看出，从根集到一个对象可以由很多条路径。</p>
<p>比如到达对象5的路径就有① -&gt; ⑤，③ -&gt;⑦两条路径。由此带来了一个问题，那就是某个对象的可及性如何判断：</p>
<p>（1）单条引用路径可及性判断：</p>
<p>在这条路径中，最弱的一个引用决定对象的可及性。</p>
<p>（2）多条引用路径可及性判断：</p>
<p>几条路径中，最强的一条的引用决定对象的可及性。</p>
<p>比如，我们假设图2中引用①和③为强引用，⑤为软引用，⑦为弱引用，对于对象5按照这两个判断原则，路径①-⑤取最弱的引用⑤，因此该路径对对象5的引用为软引用。同样，③-⑦为弱引用。在这两条路径之间取最强的引用，于是对象5是一个软可及对象。</p>
<p><strong>比较容易理解的是Java垃圾回收器会优先清理可及强度低的对象</strong></p>
<p>另外两个重要的点：</p>
<p><strong>强可达的对象一定不会被清理</strong></p>
<p><strong>JVM保证抛出out of memory之前，清理所有的软引用对象</strong></p>
<p>最后总结成一张表格：</p>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>被垃圾回收时间</th>
<th>用途</th>
<th>生存时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>强引用</td>
<td>从来不会</td>
<td>对象的一般状态</td>
<td>JVM停止运行时终止</td>
</tr>
<tr>
<td>软引用</td>
<td>在内存不足时</td>
<td>对象缓存</td>
<td>内存不足时终止</td>
</tr>
<tr>
<td>弱引用</td>
<td>在垃圾回收时</td>
<td>对象缓存</td>
<td>垃圾回收时终止</td>
</tr>
<tr>
<td>虚引用</td>
<td>Unkonwn</td>
<td>Unkonwn</td>
<td>Unkonwn</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
        <category>Reference</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>Reference</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池调优的原则与方法</title>
    <url>/articles/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%B0%83%E4%BC%98%E7%9A%84%E5%8E%9F%E5%88%99%E4%B8%8E%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1>Java线程池调优的原则与方法</h1>
<h2 id="1-合理配置线程池大小"><a class="header-anchor" href="#1-合理配置线程池大小">¶</a>1.合理配置线程池大小</h2>
<p>根据系统的资源限制和应用的特点来设置线程池的大小。如果线程池过小，可能会造成线程饥饿；如果线程池过大，可能会导致系统资源浪费。</p>
<ol>
<li>CPU密集型任务配置尽可能少的线程数量，如配置 cpu数+1 个线程的线程池。</li>
<li>IO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如 2*cpu数。</li>
<li>混合型的任务，
<ul>
<li>如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率。</li>
<li>如果这两个任务执行时间相差太大，则没必要进行分解。</li>
</ul>
</li>
<li>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。</li>
</ol>
<h2 id="2-避免长时间阻塞"><a class="header-anchor" href="#2-避免长时间阻塞">¶</a>2. 避免长时间阻塞</h2>
<p>线程阻塞时间过长可能会导致线程池中的线程资源浪费，因此应该避免长时间阻塞。</p>
<h2 id="3-合理使用阻塞队列"><a class="header-anchor" href="#3-合理使用阻塞队列">¶</a>3. 合理使用阻塞队列</h2>
<p>在线程池中使用阻塞队列可以控制任务的执行速度，以避免系统压力过大。</p>
<p>建议使用有界队列，避免<code>Out of memory</code>， 增加系统的稳定性和预警能力。可以根据需要设大一点，比如几千。</p>
<p>如果使用无界队列如 <code>LinkedBlockingQueue</code>，队列可能越来越大，最后撑满内存，可能导致整个系统奔溃。</p>
<h2 id="4-使用正确的线程池类型"><a class="header-anchor" href="#4-使用正确的线程池类型">¶</a>4. 使用正确的线程池类型</h2>
<p>Java提供了多种不同的线程池类型，如<code>FixedThreadPool</code> 、<code>CachedThreadPool</code> 等，选择合适的线程池类型可以提高线程池的效率。</p>
<p><code>SingleThreadExecutor</code> ：适用于串行执行任务的场景，一个任务一个任务地执行。</p>
<p><code>FixedThreadPool</code>：适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p>
<p><code>CachedThreadPool</code> : 用于并发执行大量短期的小任务。</p>
<p><code>ScheduledThreadPool</code> : 周期性执行任务的场景，需要限制线程数量的场景.</p>
<h2 id="5-定期监控线程池"><a class="header-anchor" href="#5-定期监控线程池">¶</a>5. 定期监控线程池</h2>
<p>该定期监控线程池的状态，以确保它始终处于正常运行状态。</p>
<ul>
<li>
<p>taskCount：线程池需要执行的任务数量。</p>
</li>
<li>
<p>completedTaskCount：线程池在运行过程中已完成的任务数量。小于或等于taskCount。</p>
</li>
<li>
<p>largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</p>
</li>
<li>
<p>getPoolSize:线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减。</p>
</li>
<li>
<p>getActiveCount：获取活动的线程数。</p>
</li>
</ul>
<p>这些方法是优化Java线程池的常见方法，具体的优化方案取决于应用的具体情况。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Multi-thread</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>线程池</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux权限rwx管理+定时任务调度</title>
    <url>/articles/Linux%E6%9D%83%E9%99%90rwx%E7%AE%A1%E7%90%86+%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h1>组管理和权限管理</h1>
<h2 id="1、所有者"><a class="header-anchor" href="#1、所有者">¶</a>1、所有者</h2>
<p>文件a.txt的三概念</p>
<ul>
<li>所有者：谁创建的，可改    -------》比如根目录是root的，所以lzw就不能在那创建dir02</li>
<li>所在组：所有者所在的组，<strong>组内其他成员对文件有点权限</strong>。</li>
<li>其他组：</li>
<li>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436031.png" alt="image-20211210185737254" style="zoom: 67%;" />
</li>
</ul>
<p>命令</p>
<ul>
<li>ls -ahl   <strong>查看</strong>所有者</li>
</ul>
<p><img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436032.png" alt="image-20211224181945716"></p>
<ul>
<li>chown tom apple.txt   <strong>更改</strong>所有者</li>
</ul>
<p><img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436033.png" alt="image-20211224182616934"></p>
<h2 id="2、所在组"><a class="header-anchor" href="#2、所在组">¶</a>2、所在组</h2>
<p>就是day02用户组那里</p>
<p><img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436034.png" alt="image-20211224183103295"></p>
<ul>
<li>
<p>ls -l     ----<strong>看</strong>所在组</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436036.png" alt="image-20211224183257114" style="zoom:80%;" />
</li>
<li>
<p>chgrp 组名 文件名    ----<strong>修改</strong>文件的所在组</p>
</li>
</ul>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436037.png" alt="image-20211224184555425" style="zoom:80%;" />
<ul>
<li>usermod -g 新组名 用户名  —<strong>修改</strong>用户的组</li>
</ul>
<p><img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436038.png" alt="image-20211224184523324"></p>
<h2 id="3、rwx权限"><a class="header-anchor" href="#3、rwx权限">¶</a>3、rwx权限</h2>
<p>第0位，文件类型（dev目录有很多character文件</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436039.png" alt="image-20211226181515228" style="zoom:80%;" />
<p>比如b块设备</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436040.png" alt="image-20211226181847468" style="zoom:80%;" />
<blockquote>
<p>第1-3位，所有者的权限</p>
<p>第4-6位，组内其他人的权限</p>
<p>第7-9位，其他用户的权限</p>
<p>读文件只需 <code>文件r+目录x</code>，无需目录r</p>
<p><img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436041.png" alt="image-20211228105736423" style="zoom:80%;" />1</p>
</blockquote>
<p><strong>重要</strong>：<code>目录的x执行权限，是读写删增目录内文件的基础</code></p>
<h2 id="4、rwx举例"><a class="header-anchor" href="#4、rwx举例">¶</a>4、rwx举例</h2>
<h3 id="1）看文件的rwx内容"><a class="header-anchor" href="#1）看文件的rwx内容">¶</a>1）看文件的rwx内容</h3>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436042.png" alt="image-20211226183509967" style="zoom:80%;" />
<h3 id="2）修改rwx权限—chmod"><a class="header-anchor" href="#2）修改rwx权限—chmod">¶</a>2）修改rwx权限—chmod</h3>
<p>给哪些<a href=""><strong>人</strong></a>权限？</p>
<ul>
<li>u  所有者</li>
<li>g  组内其他人</li>
<li>o  外人</li>
<li>a  <u>每个人</u></li>
</ul>
<p>给的<a href=""><strong>权限</strong></a>有哪些？</p>
<ol>
<li>r   读</li>
<li>w  写</li>
<li>x   执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用字母</span><br><span class="line">chmod u=rwx,g=rx,o=x 文件名    ---</span><br><span class="line">    </span><br><span class="line">chmod o+w 文件名       ---给外人赋予“读”</span><br><span class="line">    </span><br><span class="line">chmod a-x 文件名      ---给所有人剥夺“执行权限”</span><br></pre></td></tr></table></figure>
<p>用**<a href="">数字表权限</a>**</p>
<p>r=4， w=2， x=1</p>
<ul>
<li>1  是x</li>
<li>2  是w</li>
<li>3  是x+w</li>
<li>4  是r</li>
<li>5  是r+x</li>
<li>6  是r+w</li>
<li>7  是rwx</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">用数字</span><br><span class="line">chmod <span class="number">751</span> 文件名      <span class="comment">---等同于上面的</span></span><br></pre></td></tr></table></figure>
<h3 id="3）修改所有者—chown"><a class="header-anchor" href="#3）修改所有者—chown">¶</a>3）修改所有者—chown</h3>
<p>-R   让**<a href="">目录</a>**的儿孙们都生效</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">chown  tom  文件名    ---文件所有者变成tom</span><br><span class="line"></span><br><span class="line">chown  tom:cat  文件名   ---所有者tom，组为cat</span><br><span class="line"></span><br><span class="line">chown  -<span class="type">R</span> tom  目录   ---目录所有儿孙的主人都是tom</span><br></pre></td></tr></table></figure>
<h3 id="4）修改所在组—chgrp"><a class="header-anchor" href="#4）修改所在组—chgrp">¶</a>4）修改所在组—chgrp</h3>
<p>-R   让**<a href="">目录</a>**的儿孙们都生效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">chgrp shaolin /home/abc.txt  ---abc.txt组改为shaolin </span><br><span class="line"></span><br><span class="line">chgrp -R shaolin /home/test  ---test文件夹组改为shaolin</span><br></pre></td></tr></table></figure>
<h3 id="5）综合栗子"><a class="header-anchor" href="#5）综合栗子">¶</a>5）综合栗子</h3>
<p>警察和土匪</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436043.png" alt="image-20211226211052435" style="zoom:80%;" />
<p>西游记</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436044.png" alt="image-20211226212626897" style="zoom:80%;" />
<h1>定时任务调度crond—反复性</h1>
<p>病毒扫描，用户mysql数据库的备份</p>
<p>-e  **<a href="">编辑</a>**crontab定时任务</p>
<p>-l   <a href=""><strong>查询</strong></a>crontab任务</p>
<p>-r  **<a href="">删除</a>**当前用户的crontab任务             —记得终止，<strong>免得不堪重负</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">crontab -e     ---编辑定时任务</span><br><span class="line"></span><br><span class="line">*/<span class="number">1</span> * * * * ls -l /home/ &gt; /usr/a.txt     ---每隔一分钟把home下内容，重定向写到a.txt中   </span><br><span class="line">    </span><br><span class="line">service crond restart     ---重启任务调度</span><br></pre></td></tr></table></figure>
<h2 id="1、时间规则"><a class="header-anchor" href="#1、时间规则">¶</a>1、时间规则</h2>
<blockquote>
<p>五个占位符</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436045.png" alt="image-20211228162008090" style="zoom:80%;" />
</blockquote>
<blockquote>
<p>占位符的种类</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436046.png" alt="image-20211228162326304" style="zoom:80%;" />
</blockquote>
<blockquote>
<p>案例</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436047.png" alt="image-20211228165024130" style="zoom:80%;" />
</blockquote>
<h2 id="2、应用实例"><a class="header-anchor" href="#2、应用实例">¶</a>2、应用实例</h2>
<h3 id="1）定时执行脚本"><a class="header-anchor" href="#1）定时执行脚本">¶</a>1）定时执行脚本</h3>
<p>每隔一分钟，把cal追加写到 /home/mycal 文件中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vim /home/jiaoben.sh     ---编辑jiaoben.sh</span><br><span class="line"></span><br><span class="line">cal &gt;&gt; /home/mycal       ---往jiaoben.sh里面写入命令</span><br><span class="line">     </span><br><span class="line">chmod u+x /home/jiaoben.sh     ---给jiaoben.sh执行权限</span><br><span class="line">    </span><br><span class="line">crontab -e         ---编辑crontab任务</span><br><span class="line">    </span><br><span class="line">*/<span class="number">1</span> * * * * /home/jiaoben.sh    ---往crontab写入定时任务</span><br></pre></td></tr></table></figure>
<h3 id="2）定时备份mysql"><a class="header-anchor" href="#2）定时备份mysql">¶</a>2）定时备份mysql</h3>
<p>每天2:00把mysql数据库testdb，备份到文件中，</p>
<p>指令为：mysqldump  -uroot  -p密码  库名  &gt;  /home/db.bak</p>
<p>可选</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> * * * mysqldump -uroot -proot 【--host=某】 --databases=testdb &gt; /home/db.bak</span><br></pre></td></tr></table></figure>
<h1>at定时任务—一次性</h1>
<p>只执行一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ps  -ef  |  grep atd     ---查看atd守护进程运行</span><br><span class="line"></span><br><span class="line">Ctrl+D    ---结束at命令的输入</span><br><span class="line">    </span><br><span class="line">atq       ---查看执行的工作任务   </span><br><span class="line">    </span><br><span class="line">atrm 编号  ---删除某任务    </span><br></pre></td></tr></table></figure>
<blockquote>
<p>选项</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436048.png" alt="image-20211228200533422" style="zoom: 50%;" />
</blockquote>
<blockquote>
<p>时间</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436049.png" alt="image-20211228200934044" style="zoom:80%;" />
</blockquote>
<h2 id="1、实例"><a class="header-anchor" href="#1、实例">¶</a>1、实例</h2>
<p>两天后的下午5点执行	/bin/ls   /home</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436050.png" alt="image-20211228202108473" style="zoom:80%;" />
<p><img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436051.png" alt="image-20211228202322938"></p>
<p>明天17点，输出时间到 /root/date100.log</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436052.png" alt="image-20211228202701864" style="zoom:80%;" />
<p>两分钟后执行脚本script</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202301081436053.png" alt="image-20211228204350070" style="zoom:80%;" />]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>rwx</tag>
        <tag>crond</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora+PicGo博客图床搭建</title>
    <url>/articles/Typora+PicGo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1>图床存图片，哪哪都能看</h1>
<p>本人使用 <code>Typora</code> 编辑Markdown文档来上传到博客，但本地图片上传到GitHub博客，就没法看了，为此寻找了多种方法。 最后选择了阿里云OSS存储作为图床，<code>PicGo</code>软件上传，<code>Typora</code>引用网址的方式</p>
<h2 id="1、本地同名文件夹引用，失效"><a class="header-anchor" href="#1、本地同名文件夹引用，失效">¶</a>1、本地同名文件夹引用，失效</h2>
<ol>
<li>下载处理图片的插件</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">npm install https:<span class="comment">//github.com/CodeFalling/hexo-asset-image --save</span></span><br><span class="line">或</span><br><span class="line">npm install hexo-asset-img --save    </span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>在Hexo配置文件将配置项post_asset_folder设为true</p>
</li>
<li>
<p>设置Typora放图片的方式，自动把图片放到同名文件夹下</p>
</li>
</ol>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212062229102.png" alt="image-20221206222940084" style="zoom:80%;" />
<ol start="4">
<li>执行命令 <code>hexo new article_name</code>，在source/_posts中会生成文章article_name.md和同名文件夹article_name。将图片资源放在article_name文件夹中，文章就可以使用相对路径引用图片资源了。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">![可选图片描述](文章名/图片名.png)  </span><br></pre></td></tr></table></figure>
<h2 id="2、GitHub图床，失效"><a class="header-anchor" href="#2、GitHub图床，失效">¶</a>2、GitHub图床，失效</h2>
<ul>
<li>登录自己的github，建立一个<strong>公开</strong>的仓库，用于存储图片</li>
<li>进入personal settings -&gt; developer settings -&gt; personal access tokens -&gt; generate new token</li>
</ul>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212062237974.png" alt="image-20221206223720588" style="zoom:80%;" />
<ul>
<li>生成token信息，及时复制出现的token</li>
<li>下载Windows的PicGo的exe文件，如PicGo-Setup-2.3.0-x64.exe，  链接：<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></li>
<li>设置PicGo，开启<strong>时间戳重命名</strong>。</li>
</ul>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212062240680.png" alt="image-20221206224009940" style="zoom:80%;" />
<ul>
<li>Typora设置</li>
</ul>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212062241782.png" alt="image-20221206224141673" style="zoom:80%;" />
<ul>
<li>点击<strong>验证图片上传选项</strong> ，看到success就大功告成！</li>
</ul>
<h2 id="3、Gitee图床，失效"><a class="header-anchor" href="#3、Gitee图床，失效">¶</a>3、Gitee图床，失效</h2>
<p><u>设置方式和GitHub图床类似</u></p>
<p><strong>在不好用这方面，和GitHub图床类似，水平十分接近。 Gitee网速稍微快一点</strong></p>
<p>Typora把图片给PicGo，PicGo用于上传，Gitee仓库用于存放图片。</p>
<ul>
<li>GitHub单仓库1Gb~5GB，单文件最大100MB</li>
<li>Gitee单仓库最大500MB，单文件最大50M，总仓库5GB；</li>
</ul>
<blockquote>
<p>Gitee用于图床的个人密钥：xxxxxxxxxxx ， 被PicGo用于上传图片，让Gitee知道是自己人。 但查看图片不限于自己人<br>
<code>https://gitee.com/码云账户名/仓库名/raw/master/</code> 图片存时，前缀地址<br>
图片每次都会暂时存在<code>C:/Users/用户/AppData/Roaming/Typora/typora-user-images</code>， 害怕它会越存越大，解决办法是：先保存在./pictures下，需要时再上传到图床。<br>
可以一次性上传所有本地pictures， “格式” -&gt; “图像” -&gt; “上传所有本地图片” （不用担心上传几百张，它只上传当下folder的pictures</p>
</blockquote>
<p>参考链接：<a href="https://cloud.tencent.com/developer/article/1801576">https://cloud.tencent.com/developer/article/1801576</a></p>
<h2 id="4、阿里云OSS图床，最终方案"><a class="header-anchor" href="#4、阿里云OSS图床，最终方案">¶</a>4、阿里云OSS图床，最终方案</h2>
<h3 id="4-1-开通OSS对象存储"><a class="header-anchor" href="#4-1-开通OSS对象存储">¶</a>4.1 开通OSS对象存储</h3>
<p>在阿里云官网OSS <a href="https://www.aliyun.com/product/oss">对象存储OSS_云存储服务_-阿里云 (aliyun.com)</a> 点击 “立即开通”</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212070032355.png" alt="image-20221206233659678" style="zoom:80%;" />
<p>注册账户，实名。  （如果是新用户，还可以超低价买云服务器，可以用来练习Linux命令、部署网站等）</p>
<p>点击oss页面 “管理控制台”</p>
<h3 id="4-2-创建Bucket"><a class="header-anchor" href="#4-2-创建Bucket">¶</a>4.2 创建Bucket</h3>
<p>在<a href="https://oss.console.aliyun.com/bucket">OSS管理控制台 (aliyun.com)</a> 创建Bucket</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212070032356.png" alt="image-20221206234124640" style="zoom:80%;" />
<blockquote>
<ol>
<li>Bucket名称不能有大写字母，不能中文。 建议全小写英文，中间以<code>-</code>连接。如 <code>blog-img-oss</code></li>
<li>服务器选离自己近的</li>
<li>Endpoint默认，所属资源组默认</li>
<li>存储类型： <strong>标准存储</strong>（因为博客网所需流量和容量大，如果访问很少选<u>低频访问存储</u>）</li>
<li>读写权限： 一定要是<strong>公共读</strong>！ (私有别人看不了你图片，公共读写太危险)</li>
<li>其余的，都不听不要不开通！！ HDFS服务、冗余存储、版本控制、加密方式、日志查询、定时备份</li>
</ol>
</blockquote>
<p>复制你的地域节点，如<code>oss-cn-beijing</code> ，后面的 <code>.aliyuncs.com</code> 不复制。</p>
<h3 id="4-3-复制AccessKey和AccessKeySecret"><a class="header-anchor" href="#4-3-复制AccessKey和AccessKeySecret">¶</a>4.3 复制AccessKey和AccessKeySecret</h3>
<p>依次点击 <u>头像</u> -&gt; AccessKey管理 -&gt; 继续使用AccessKey -&gt; 创建AccessKey</p>
<p>一系列操作后，复制你的<code>accessKeyId</code>和<code>accessKeySecret</code></p>
<p><img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212070004317.png" alt=""></p>
<h3 id="4-4-充钱"><a class="header-anchor" href="#4-4-充钱">¶</a>4.4 充钱</h3>
<p>见名知意，阿里云首页-&gt;费用</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212070008232.png" alt="image-20221207000842470" style="zoom:80%;" />
<p>主要分容量和流量(流入/留出)，费用很便宜</p>
<ul>
<li>容量：0.12元/GB/月</li>
<li>图片<strong>上传</strong>到阿里OSS流量：免费</li>
<li>用户查看你的博客图片，<strong>流出</strong>流量： 闲时<u>0.25元/GB</u>，忙时<u>0.50元/GB</u></li>
</ul>
<h3 id="4-5-PicGo图床设置"><a class="header-anchor" href="#4-5-PicGo图床设置">¶</a>4.5 PicGo图床设置</h3>
<p>刚复制的那些内容派上用场了，点击确定，设为默认图床。</p>
<p>PicGo设置开启 “时间戳重命名”</p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212070016467.png" alt="image-20221207001600070" style="zoom:80%;" />
<h3 id="4-6-Typora设置"><a class="header-anchor" href="#4-6-Typora设置">¶</a>4.6 Typora设置</h3>
<p>验证成功，直接在Typora粘贴图片，自动由PicGo上传到OSS。</p>
<p>图片链接如：<a href="https://xn--Bucket-on9im33a.xn--6qq04ao0deyay3ll6f.aliyuncs.com/%E4%BD%A0%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84/%E5%9B%BE%E7%89%87%E5%90%8D">https://你Bucket名.你存储区域名.aliyuncs.com/你存储路径/图片名</a></p>
<img src="https://oss-hexo-blog.oss-cn-shanghai.aliyuncs.com/images/202212070022192.png" alt="image-20221207002129577" style="zoom:80%;" />]]></content>
      <categories>
        <category>Tool</category>
        <category>图床</category>
      </categories>
      <tags>
        <tag>图床</tag>
        <tag>PicGo</tag>
        <tag>Typora</tag>
        <tag>OSS</tag>
        <tag>Aliyun</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/articles/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2>
<h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>nvm管理NodeJS</title>
    <url>/articles/nvm%E7%AE%A1%E7%90%86NodeJS/</url>
    <content><![CDATA[<h1>nvm管理NodeJs</h1>
<h2 id="nvm安装配置"><a class="header-anchor" href="#nvm安装配置">¶</a>nvm安装配置</h2>
<p>推荐使用NodeJs的版本管理工具nvm，安装node更容易，允许多个node版本共存，切换方便。</p>
<p><strong>完全卸载NodeJS</strong> ：</p>
<ol>
<li>控制面板卸载NodeJS，更推荐使用Geek Uninstaller和Wise Program Uninstaller</li>
<li>重启任务管理器，鲨掉所有与node有关进程。</li>
<li>删掉 <code>C:\Users\admin\.npmrc</code> 文件</li>
<li>寻找以下目录删掉
<ul>
<li>C:\Program Files (x86)\nodejs</li>
<li>C:\Program Files\nodejs</li>
<li>C:\Users\用户名\AppData\Roaming\npm</li>
<li>C:\Users\用户名\AppData\Roaming\npm-cache</li>
</ul>
</li>
<li>删有关node的环境变量。</li>
</ol>
<p><strong>下载安装nvm</strong>：</p>
<p>下载前确定node已经卸载干净。到<a href="https://github.com/coreybutler/nvm-windows/releases">github.com</a> 该网址的下载nvm-setup.zip或nvm-setup.exe</p>
<p>双击安装exe，一路猛戳下一步，默认下载到 <code>C:\Users\用户\AppData\Roaming\nvm</code></p>
<blockquote>
<p>安装好nvm后，由于国内下载速度慢，所以使用淘宝镜像。在nvm安装目录下找到settings.txt文件。在最后面回车加上：</p>
<p>node_mirror: <a href="http://npm.taobao.org/mirrors/node/">http://npm.taobao.org/mirrors/node/</a></p>
<p>npm_mirror: <a href="https://npm.taobao.org/mirrors/npm/">https://npm.taobao.org/mirrors/npm/</a></p>
</blockquote>
<p><strong>nvm常用命令</strong> ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nvm <span class="built_in">list</span>   				看本地有哪些版本NodeJs，正在使用的NodeJs会用*号标识</span><br><span class="line">nvm <span class="built_in">list</span> available    		看网上有哪些可以下载的node版本</span><br><span class="line">nvm install <span class="number">16.16</span><span class="number">.0</span>    		下载<span class="number">16.16</span><span class="number">.0</span>版本的NodeJs到nvm安装目录</span><br><span class="line">nvm uninstall <span class="number">16.16</span><span class="number">.0</span>  		 卸载<span class="number">16</span>。<span class="number">16.0</span>的NodeJs    </span><br><span class="line">nvm use <span class="number">16.16</span><span class="number">.0</span>   使用node    </span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="https://blog.csdn.net/lewky_liu/article/details/87959839">Windows完全卸载node.js并安装node.js的多版本管理工具nvm</a></p>
<h2 id="NodeJS"><a class="header-anchor" href="#NodeJS">¶</a>NodeJS</h2>
<p><strong>NodeJS介绍</strong>：简称 <code>node</code> ，类似后端语言的JavaScript环境，本质上是浏览器底层，自带的包管理器npm在前端能充当Maven一样的角色。</p>
<p><strong>node版本</strong>：2022年Hexo要求<u>Node版本必须14以上</u>，推荐16或18，太高或者太低都不好。 另外，Node版本选双不选单。</p>
<p><strong>下载安装</strong>： 直接用nvm下载node</p>
<blockquote>
<p>切换node或是<code>nvm use 16.16.0</code> 之前，需要先把<code>C:\Users\用户\.npmrc</code> 文件删掉，就像之前的卸载node一样。</p>
<p>再执行以下命令</p>
<p>npm cache clean --force                  清理缓存</p>
<p>npm config set registry <a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a>       node使用淘宝代理链接</p>
<p>npm config set cache “C:\Users\用户\AppData\Roaming\nvm\v版本号\node_cache”     node_cache文件夹没有则新建</p>
<p>npm config set prefix “C:\Users\用户\AppData\Roaming\nvm\v版本号\node_global”      node_global文件夹没有则新建</p>
</blockquote>
<p><strong>node和npm常用命令</strong> ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">node -v    		看node版本</span><br><span class="line">npm -v    		看npm版本</span><br><span class="line">npm config <span class="built_in">list</span>   			看npm配置项    </span><br><span class="line">npm config get registry     看是否在使用淘宝代理链接</span><br><span class="line">npm install 某           下载某依赖</span><br><span class="line">npm uninstall 某 -g       全局下载某依赖    </span><br><span class="line">npm uninstall 某  		卸载某依赖    </span><br></pre></td></tr></table></figure>
<p>参考链接：跳转前可以给我点一个赞吗，拜托拜托`(<em>&gt;﹏&lt;</em>)′  <a href="https://blog.csdn.net/Kenvinxu/article/details/106053210">https://blog.csdn.net/Kenvinxu/article/details/106053210</a></p>
<p>官网版本：<a href="https://nodejs.org/zh-cn/download/releases/">以往的版本 | Node.js (nodejs.org)</a></p>
]]></content>
      <categories>
        <category>Tool</category>
        <category>nvm</category>
      </categories>
      <tags>
        <tag>Tutorial</tag>
        <tag>nvm</tag>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/articles/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1>第一章</h1>
<p>内<code>容</code>…</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">    world</span><br></pre></td></tr></table></figure>
<h1>第二章</h1>
<blockquote>
<p>hello</p>
</blockquote>
<h2 id="2-1-标题"><a class="header-anchor" href="#2-1-标题">¶</a>2.1 标题</h2>
<ul>
<li>内容</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
</search>
